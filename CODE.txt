#include <QTRSensors.h>

// Define QTR-8A sensor
QTRSensors qtr;
const uint8_t SensorCount = 8;
uint16_t sensorValues[SensorCount];

// PID Constants (Fine-tune these if needed)
#define KP 0.6  // Proportional Gain
#define KD 2.0  // Derivative Gain

int lastError = 0;

// Motor driver pins (TB6612FNG)
#define PWMA 3  // Right motor speed
#define AIN1 4
#define AIN2 5
#define STBY 6
#define BIN1 7
#define BIN2 8
#define PWMB 9  // Left motor speed

void setup() {
  Serial.begin(9600);

  // Initialize QTR-8A sensor
  qtr.setTypeAnalog();
  qtr.setSensorPins((const uint8_t[]){A0, A1, A2, A3, A4, A5, A6, A7}, SensorCount);

  // Set motor driver pins as OUTPUT
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(PWMA, OUTPUT);
  pinMode(PWMB, OUTPUT);
  pinMode(STBY, OUTPUT);
  
  digitalWrite(STBY, HIGH); // Enable motor driver

  // Auto-Calibration on Startup
  Serial.println("Starting Auto-Calibration...");
  calibrateSensors();
}

void calibrateSensors() {
  Serial.println("Calibrating Sensors...");
  delay(500);
  
  for (int i = 0; i < 100; i++) {  // Run 100 calibration cycles
    qtr.calibrate();
    Serial.print(".");
    delay(20);
  }
  Serial.println("\nCalibration Complete!");
}

void loop() {
  // Read sensor values
  int position = qtr.readLineBlack(sensorValues);
  int error = position - 3500; // 3500 is the center position
  int motorSpeed = KP * error + KD * (error - lastError);
  lastError = error;

  int baseSpeed = 100; // Base speed of motors
  int leftMotorSpeed = baseSpeed + motorSpeed;
  int rightMotorSpeed = baseSpeed - motorSpeed;

  // Limit motor speed
  leftMotorSpeed = constrain(leftMotorSpeed, -255, 255);
  rightMotorSpeed = constrain(rightMotorSpeed, -255, 255);

  // Move motors based on PID output
  moveMotor(leftMotorSpeed, rightMotorSpeed);
}

void moveMotor(int leftSpeed, int rightSpeed) {
  // Right motor control
  if (rightSpeed > 0) {
    digitalWrite(AIN1, HIGH);
    digitalWrite(AIN2, LOW);
    analogWrite(PWMA, rightSpeed);
  } else if (rightSpeed < 0) {
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, HIGH);
    analogWrite(PWMA, -rightSpeed);
  } else {
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, LOW);
  }

  // Left motor control
  if (leftSpeed > 0) {
    digitalWrite(BIN1, HIGH);
    digitalWrite(BIN2, LOW);
    analogWrite(PWMB, leftSpeed);
  } else if (leftSpeed < 0) {
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, HIGH);
    analogWrite(PWMB, -leftSpeed);
  } else {
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, LOW);
  }
}



















#include <QTRSensors.h>
#include <SparkFun_TB6612.h>

#define AIN1 5
#define BIN1 7
#define AIN2 4
#define BIN2 8
#define PWMA 3
#define PWMB 9
#define STBY 6

const int offsetA = 1;
const int offsetB = 1;

Motor motor1 = Motor(AIN1, AIN2, PWMA, offsetA, STBY);
Motor motor2 = Motor(BIN1, BIN2, PWMB, offsetB, STBY);

QTRSensors qtr;

const uint8_t SensorCount = 8;
uint16_t sensorValues[SensorCount];

int max_speed = 220;  // âœ… Reduced from 255 for better control
int turn_speed = 140; // âœ… Adjusted for smoother turns
int min_speed = 50;   // âœ… Prevents stalling

int L = 0, R = 0;
int error = 0, adj = 0;

float Kp = 0.078;  // âœ… Increased for sharper response
float Ki = 0.006;  // âœ… Lowered to avoid excessive accumulation
float Kd = 1.5;    // âœ… Increased to reduce oscillations

int P, I, D;
int lastError = 0;
uint16_t position;

// âœ… Stop Detection Variables
unsigned long blackStartTime = 0;
const unsigned long blackThreshold = 1500; // âœ… Stop after 1.5s on black

void setup() {
    Serial.begin(9600);

    brake();
    pinMode(STBY, OUTPUT);
    digitalWrite(STBY, HIGH);  // âœ… Ensure motors are active

    qtr.setTypeAnalog();
    qtr.setSensorPins((const uint8_t[]){ A0, A1, A2, A3, A4, A5, A6, A7 }, SensorCount);
    qtr.setEmitterPin(2);

    Serial.println("Calibrating...");
    for (uint16_t i = 0; i < 150; i++) {  // âœ… Reduced calibration time
        qtr.calibrate();
        delay(10);
    }

    Serial.println("Done");
}

void loop() {
    PID_control();
}

// âœ… PID CONTROL FUNCTION
void PID_control() {
    position = qtr.readLineWhite(sensorValues);
    Serial.print("QTR Position: ");
    Serial.println(position);

    error = 3500 - position;

    // âœ… Black Line (Finish Line) Detection
    bool allBlack = true;
    for (int i = 0; i < SensorCount; i++) {
        if (sensorValues[i] < 900) {  // âœ… Adjust threshold if needed
            allBlack = false;
            break;
        }
    }

    if (allBlack) {
        if (blackStartTime == 0) {
            blackStartTime = millis();
        } else if (millis() - blackStartTime >= blackThreshold) {
            brake();
            Serial.println("ðŸ Robot Stopped at Finish Line!");
            while (true) delay(1000); // âœ… Prevents further execution
        }
    } else {
        blackStartTime = 0;  // âœ… Reset timer if not on finish line
    }

    // âœ… Turning Adjustments
    if (error > 2000) {  
        L = turn_speed;
        R = min_speed;  // âœ… Reduce speed for sharp left
    } else if (error < -2000) {  
        L = min_speed;  
        R = turn_speed;  // âœ… Reduce speed for sharp right
    } else {  // âœ… Normal PID control
        P = error;
        I += error;
        I = constrain(I, -300, 300);  // âœ… Integral windup protection
        D = error - lastError;
        lastError = error;

        adj = P * Kp + I * Ki + D * Kd;

        L = max_speed + adj;
        R = max_speed - adj;

        L = constrain(L, min_speed, max_speed);
        R = constrain(R, min_speed, max_speed);
    }

    forward(L, R);
}

// âœ… ROBOT MOVEMENT FUNCTIONS
void forward(int L, int R) {
    digitalWrite(STBY, HIGH);
    motor1.drive(L);
    motor2.drive(R);
}

void sharp_right() {
    digitalWrite(STBY, HIGH);
    motor1.drive(-turn_speed);
    motor2.drive(turn_speed);
}

void sharp_left() {
    digitalWrite(STBY, HIGH);
    motor1.drive(turn_speed);
    motor2.drive(-turn_speed);
}

void brake() {
    motor1.drive(0);
    motor2.drive(0);
}
